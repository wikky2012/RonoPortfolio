(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('apollo-client'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('apollo-angular', ['exports', '@angular/core', 'apollo-client', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global.ngApollo = {}, global.ng.core, global.apollo, global.rxjs, global.rxjs.operators));
}(this, (function (exports, core, apolloClient, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, exports) {
        for (var p in m)
            if (p !== "default" && !exports.hasOwnProperty(p))
                __createBinding(exports, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    function fromPromise(promiseFn) {
        return new rxjs.Observable(function (subscriber) {
            promiseFn().then(function (result) {
                if (!subscriber.closed) {
                    subscriber.next(result);
                    subscriber.complete();
                }
            }, function (error) {
                if (!subscriber.closed) {
                    subscriber.error(error);
                }
            });
            return function () { return subscriber.unsubscribe(); };
        });
    }
    var ZoneScheduler = /** @class */ (function () {
        function ZoneScheduler(zone) {
            this.zone = zone;
            this.now = Date.now ? Date.now : function () { return +new Date(); };
        }
        ZoneScheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return this.zone.run(function () { return rxjs.queueScheduler.schedule(work, delay, state); });
        };
        return ZoneScheduler;
    }());
    // XXX: Apollo's QueryObservable is not compatible with RxJS
    // TODO: remove it in one of future releases
    // https://github.com/ReactiveX/rxjs/blob/9fb0ce9e09c865920cf37915cc675e3b3a75050b/src/internal/util/subscribeTo.ts#L32
    function fixObservable(obs) {
        obs[rxjs.observable] = function () { return obs; };
        return obs;
    }
    function wrapWithZone(obs, ngZone) {
        return obs.pipe(operators.observeOn(new ZoneScheduler(ngZone)));
    }

    var QueryRef = /** @class */ (function () {
        function QueryRef(obsQuery, ngZone, options) {
            this.obsQuery = obsQuery;
            var wrapped = wrapWithZone(rxjs.from(fixObservable(this.obsQuery)), ngZone);
            this.valueChanges = options.useInitialLoading
                ? wrapped.pipe(operators.startWith(Object.assign(Object.assign({}, this.obsQuery.getCurrentResult()), { error: undefined, partial: undefined, stale: true })))
                : wrapped;
            this.queryId = this.obsQuery.queryId;
        }
        // ObservableQuery's methods
        QueryRef.prototype.result = function () {
            return this.obsQuery.result();
        };
        QueryRef.prototype.currentResult = function () {
            return this.obsQuery.currentResult();
        };
        QueryRef.prototype.getLastResult = function () {
            return this.obsQuery.getLastResult();
        };
        QueryRef.prototype.getLastError = function () {
            return this.obsQuery.getLastError();
        };
        QueryRef.prototype.resetLastResults = function () {
            return this.obsQuery.resetLastResults();
        };
        QueryRef.prototype.refetch = function (variables) {
            return this.obsQuery.refetch(variables);
        };
        QueryRef.prototype.fetchMore = function (fetchMoreOptions) {
            return this.obsQuery.fetchMore(fetchMoreOptions);
        };
        QueryRef.prototype.subscribeToMore = function (options) {
            // XXX: there's a bug in apollo-client typings
            // it should not inherit types from ObservableQuery
            return this.obsQuery.subscribeToMore(options);
        };
        QueryRef.prototype.updateQuery = function (mapFn) {
            return this.obsQuery.updateQuery(mapFn);
        };
        QueryRef.prototype.stopPolling = function () {
            return this.obsQuery.stopPolling();
        };
        QueryRef.prototype.startPolling = function (pollInterval) {
            return this.obsQuery.startPolling(pollInterval);
        };
        QueryRef.prototype.setOptions = function (opts) {
            return this.obsQuery.setOptions(opts);
        };
        QueryRef.prototype.setVariables = function (variables, tryFetch, fetchResults) {
            if (tryFetch === void 0) { tryFetch = false; }
            if (fetchResults === void 0) { fetchResults = true; }
            return this.obsQuery.setVariables(variables, tryFetch, fetchResults);
        };
        return QueryRef;
    }());

    var APOLLO_OPTIONS = new core.InjectionToken('[apollo-angular] options');
    var APOLLO_NAMED_OPTIONS = new core.InjectionToken('[apollo-angular] named options');

    var ApolloBase = /** @class */ (function () {
        function ApolloBase(ngZone, _client) {
            this.ngZone = ngZone;
            this._client = _client;
        }
        ApolloBase.prototype.watchQuery = function (options) {
            return new QueryRef(this.ensureClient().watchQuery(Object.assign({}, options)), this.ngZone, options);
        };
        ApolloBase.prototype.query = function (options) {
            var _this = this;
            return fromPromise(function () { return _this.ensureClient().query(Object.assign({}, options)); });
        };
        ApolloBase.prototype.mutate = function (options) {
            var _this = this;
            return fromPromise(function () { return _this.ensureClient().mutate(Object.assign({}, options)); });
        };
        ApolloBase.prototype.subscribe = function (options, extra) {
            var obs = rxjs.from(fixObservable(this.ensureClient().subscribe(Object.assign({}, options))));
            return extra && extra.useZone !== true
                ? obs
                : wrapWithZone(obs, this.ngZone);
        };
        /**
         * Get an access to an instance of ApolloClient
         */
        ApolloBase.prototype.getClient = function () {
            return this._client;
        };
        /**
         * Set a new instance of ApolloClient
         * Remember to clean up the store before setting a new client.
         *
         * @param client ApolloClient instance
         */
        ApolloBase.prototype.setClient = function (client) {
            if (this._client) {
                throw new Error('Client has been already defined');
            }
            this._client = client;
        };
        ApolloBase.prototype.ensureClient = function () {
            this.checkInstance();
            return this._client;
        };
        ApolloBase.prototype.checkInstance = function () {
            if (!this._client) {
                throw new Error('Client has not been defined yet');
            }
        };
        return ApolloBase;
    }());
    var Apollo = /** @class */ (function (_super) {
        __extends(Apollo, _super);
        function Apollo(_ngZone, apolloOptions, apolloNamedOptions) {
            var _this = _super.call(this, _ngZone) || this;
            _this._ngZone = _ngZone;
            _this.map = new Map();
            if (apolloOptions) {
                _this.createDefault(apolloOptions);
            }
            if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {
                for (var name in apolloNamedOptions) {
                    if (apolloNamedOptions.hasOwnProperty(name)) {
                        var options = apolloNamedOptions[name];
                        _this.createNamed(name, options);
                    }
                }
            }
            return _this;
        }
        /**
         * Create an instance of ApolloClient
         * @param options Options required to create ApolloClient
         * @param name client's name
         */
        Apollo.prototype.create = function (options, name) {
            if (isDefault(name)) {
                this.createDefault(options);
            }
            else {
                this.createNamed(name, options);
            }
        };
        /**
         * Use a default ApolloClient
         */
        Apollo.prototype.default = function () {
            return this;
        };
        /**
         * Use a named ApolloClient
         * @param name client's name
         */
        Apollo.prototype.use = function (name) {
            if (isDefault(name)) {
                return this.default();
            }
            return this.map.get(name);
        };
        /**
         * Create a default ApolloClient, same as `apollo.create(options)`
         * @param options ApolloClient's options
         */
        Apollo.prototype.createDefault = function (options) {
            if (this.getClient()) {
                throw new Error('Apollo has been already created.');
            }
            return this.setClient(new apolloClient.ApolloClient(options));
        };
        /**
         * Create a named ApolloClient, same as `apollo.create(options, name)`
         * @param name client's name
         * @param options ApolloClient's options
         */
        Apollo.prototype.createNamed = function (name, options) {
            if (this.map.has(name)) {
                throw new Error("Client " + name + " has been already created");
            }
            this.map.set(name, new ApolloBase(this._ngZone, new apolloClient.ApolloClient(options)));
        };
        /**
         * Remember to clean up the store before removing a client
         * @param name client's name
         */
        Apollo.prototype.removeClient = function (name) {
            if (isDefault(name)) {
                this._client = undefined;
            }
            else {
                this.map.delete(name);
            }
        };
        return Apollo;
    }(ApolloBase));
    Apollo.decorators = [
        { type: core.Injectable }
    ];
    Apollo.ctorParameters = function () { return [
        { type: core.NgZone },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [APOLLO_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [APOLLO_NAMED_OPTIONS,] }] }
    ]; };
    function isDefault(name) {
        return !name || name === 'default';
    }

    var Query = /** @class */ (function () {
        function Query(apollo) {
            this.apollo = apollo;
            this.client = 'default';
        }
        Query.prototype.watch = function (variables, options) {
            return this.apollo.use(this.client).watchQuery(Object.assign(Object.assign({}, options), { variables: variables, query: this.document }));
        };
        Query.prototype.fetch = function (variables, options) {
            return this.apollo.use(this.client).query(Object.assign(Object.assign({}, options), { variables: variables, query: this.document }));
        };
        return Query;
    }());
    Query.decorators = [
        { type: core.Injectable }
    ];
    Query.ctorParameters = function () { return [
        { type: Apollo }
    ]; };

    var Mutation = /** @class */ (function () {
        function Mutation(apollo) {
            this.apollo = apollo;
            this.client = 'default';
        }
        Mutation.prototype.mutate = function (variables, options) {
            return this.apollo.use(this.client).mutate(Object.assign(Object.assign({}, options), { variables: variables, mutation: this.document }));
        };
        return Mutation;
    }());
    Mutation.decorators = [
        { type: core.Injectable }
    ];
    Mutation.ctorParameters = function () { return [
        { type: Apollo }
    ]; };

    var Subscription = /** @class */ (function () {
        function Subscription(apollo) {
            this.apollo = apollo;
            this.client = 'default';
        }
        Subscription.prototype.subscribe = function (variables, options, extra) {
            return this.apollo.use(this.client).subscribe(Object.assign(Object.assign({}, options), { variables: variables, query: this.document }), extra);
        };
        return Subscription;
    }());
    Subscription.decorators = [
        { type: core.Injectable }
    ];
    Subscription.ctorParameters = function () { return [
        { type: Apollo }
    ]; };

    var SelectPipe = /** @class */ (function () {
        function SelectPipe() {
        }
        SelectPipe.prototype.transform = function (obj, name) {
            if (name === void 0) { name = ''; }
            if (name !== '') {
                return obj && obj.data && obj.data[name];
            }
        };
        return SelectPipe;
    }());
    SelectPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'select',
                },] }
    ];

    var PROVIDERS = [Apollo];
    var DECLARATIONS = [SelectPipe];
    var ApolloModule = /** @class */ (function () {
        function ApolloModule() {
        }
        return ApolloModule;
    }());
    ApolloModule.decorators = [
        { type: core.NgModule, args: [{
                    providers: PROVIDERS,
                    declarations: DECLARATIONS,
                    exports: DECLARATIONS,
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.APOLLO_NAMED_OPTIONS = APOLLO_NAMED_OPTIONS;
    exports.APOLLO_OPTIONS = APOLLO_OPTIONS;
    exports.Apollo = Apollo;
    exports.ApolloBase = ApolloBase;
    exports.ApolloModule = ApolloModule;
    exports.Mutation = Mutation;
    exports.Query = Query;
    exports.QueryRef = QueryRef;
    exports.SelectPipe = SelectPipe;
    exports.Subscription = Subscription;
    exports.ɵa = PROVIDERS;
    exports.ɵb = DECLARATIONS;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngApollo.umd.js.map
