export { default as gql } from 'graphql-tag';
export * from 'apollo-client';
import { ApolloLink, Observable } from 'apollo-link';
export * from 'apollo-link';
import { InMemoryCache } from 'apollo-cache-inmemory';
export * from 'apollo-cache-inmemory';
import { Apollo, ApolloModule } from 'apollo-angular';
export * from 'apollo-angular';
import { InjectionToken, Injectable, NgModule, Optional, Inject } from '@angular/core';
import { HttpLink, HttpLinkModule } from 'apollo-angular-link-http';
import { withClientState } from 'apollo-link-state';
import { onError } from 'apollo-link-error';

const APOLLO_BOOST_CONFIG = new InjectionToken('[apollo-angular-boost] config');

class ApolloBoost {
    constructor(apollo, httpLink) {
        this.apollo = apollo;
        this.httpLink = httpLink;
    }
    create(config) {
        const cache = config && config.cacheRedirects
            ? new InMemoryCache({ cacheRedirects: config.cacheRedirects })
            : new InMemoryCache();
        const stateLink = config && config.clientState
            ? withClientState(Object.assign(Object.assign({}, config.clientState), { cache }))
            : false;
        const errorLink = config && config.onError
            ? onError(config.onError)
            : onError(({ graphQLErrors, networkError }) => {
                if (graphQLErrors) {
                    graphQLErrors.map(({ message, locations, path }) => 
                    // tslint:disable-next-line
                    console.log(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`));
                }
                if (networkError) {
                    // tslint:disable-next-line
                    console.log(`[Network error]: ${networkError}`);
                }
            });
        const requestHandler = config && config.request
            ? new ApolloLink((operation, forward) => new Observable((observer) => {
                let handle;
                Promise.resolve(operation)
                    .then((oper) => config.request(oper))
                    .then(() => {
                    handle = forward(operation).subscribe({
                        next: observer.next.bind(observer),
                        error: observer.error.bind(observer),
                        complete: observer.complete.bind(observer),
                    });
                })
                    .catch(observer.error.bind(observer));
                return () => {
                    if (handle) {
                        handle.unsubscribe();
                    }
                };
            }))
            : false;
        const httpLink = this.httpLink.create(Object.assign(Object.assign({}, ((config && config.httpOptions) || {})), { uri: (config && config.uri) || '/graphql' }));
        const link = ApolloLink.from([errorLink, requestHandler, stateLink, httpLink].filter((x) => !!x));
        this.apollo.create({
            link,
            cache,
        });
    }
}
ApolloBoost.decorators = [
    { type: Injectable }
];
ApolloBoost.ctorParameters = () => [
    { type: Apollo },
    { type: HttpLink }
];

class ApolloBoostModule {
    constructor(boost, config) {
        if (config) {
            boost.create(config);
        }
    }
}
ApolloBoostModule.decorators = [
    { type: NgModule, args: [{
                imports: [ApolloModule, HttpLinkModule],
                providers: [ApolloBoost],
            },] }
];
ApolloBoostModule.ctorParameters = () => [
    { type: ApolloBoost },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_BOOST_CONFIG,] }] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { APOLLO_BOOST_CONFIG, ApolloBoost, ApolloBoostModule };
//# sourceMappingURL=ngApolloBoost.js.map
