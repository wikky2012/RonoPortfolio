import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'apollo-angular';
import * as ɵngcc2 from 'apollo-angular-link-http';
export { default as gql } from 'graphql-tag';
export * from 'apollo-client';
import { ApolloLink, Observable } from 'apollo-link';
export * from 'apollo-link';
import { InMemoryCache } from 'apollo-cache-inmemory';
export * from 'apollo-cache-inmemory';
import { Apollo, ApolloModule } from 'apollo-angular';
export * from 'apollo-angular';
import { InjectionToken, Injectable, NgModule, Optional, Inject } from '@angular/core';
import { HttpLink, HttpLinkModule } from 'apollo-angular-link-http';
import { withClientState } from 'apollo-link-state';
import { onError } from 'apollo-link-error';

const APOLLO_BOOST_CONFIG = new InjectionToken('[apollo-angular-boost] config');

class ApolloBoost {
    constructor(apollo, httpLink) {
        this.apollo = apollo;
        this.httpLink = httpLink;
    }
    create(config) {
        const cache = config && config.cacheRedirects
            ? new InMemoryCache({ cacheRedirects: config.cacheRedirects })
            : new InMemoryCache();
        const stateLink = config && config.clientState
            ? withClientState(Object.assign(Object.assign({}, config.clientState), { cache }))
            : false;
        const errorLink = config && config.onError
            ? onError(config.onError)
            : onError(({ graphQLErrors, networkError }) => {
                if (graphQLErrors) {
                    graphQLErrors.map(({ message, locations, path }) => 
                    // tslint:disable-next-line
                    console.log(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`));
                }
                if (networkError) {
                    // tslint:disable-next-line
                    console.log(`[Network error]: ${networkError}`);
                }
            });
        const requestHandler = config && config.request
            ? new ApolloLink((operation, forward) => new Observable((observer) => {
                let handle;
                Promise.resolve(operation)
                    .then((oper) => config.request(oper))
                    .then(() => {
                    handle = forward(operation).subscribe({
                        next: observer.next.bind(observer),
                        error: observer.error.bind(observer),
                        complete: observer.complete.bind(observer),
                    });
                })
                    .catch(observer.error.bind(observer));
                return () => {
                    if (handle) {
                        handle.unsubscribe();
                    }
                };
            }))
            : false;
        const httpLink = this.httpLink.create(Object.assign(Object.assign({}, ((config && config.httpOptions) || {})), { uri: (config && config.uri) || '/graphql' }));
        const link = ApolloLink.from([errorLink, requestHandler, stateLink, httpLink].filter((x) => !!x));
        this.apollo.create({
            link,
            cache,
        });
    }
}
ApolloBoost.ɵfac = function ApolloBoost_Factory(t) { return new (t || ApolloBoost)(ɵngcc0.ɵɵinject(ɵngcc1.Apollo), ɵngcc0.ɵɵinject(ɵngcc2.HttpLink)); };
ApolloBoost.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ApolloBoost, factory: ApolloBoost.ɵfac });
ApolloBoost.ctorParameters = () => [
    { type: Apollo },
    { type: HttpLink }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ApolloBoost, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Apollo }, { type: ɵngcc2.HttpLink }]; }, null); })();

class ApolloBoostModule {
    constructor(boost, config) {
        if (config) {
            boost.create(config);
        }
    }
}
ApolloBoostModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ApolloBoostModule });
ApolloBoostModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ApolloBoostModule_Factory(t) { return new (t || ApolloBoostModule)(ɵngcc0.ɵɵinject(ApolloBoost), ɵngcc0.ɵɵinject(APOLLO_BOOST_CONFIG, 8)); }, providers: [ApolloBoost], imports: [[ApolloModule, HttpLinkModule]] });
ApolloBoostModule.ctorParameters = () => [
    { type: ApolloBoost },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_BOOST_CONFIG,] }] }
];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ApolloBoostModule, { imports: function () { return [ApolloModule, HttpLinkModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ApolloBoostModule, [{
        type: NgModule,
        args: [{
                imports: [ApolloModule, HttpLinkModule],
                providers: [ApolloBoost]
            }]
    }], function () { return [{ type: ApolloBoost }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [APOLLO_BOOST_CONFIG]
            }] }]; }, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { APOLLO_BOOST_CONFIG, ApolloBoost, ApolloBoostModule };

//# sourceMappingURL=ngApolloBoost.js.map