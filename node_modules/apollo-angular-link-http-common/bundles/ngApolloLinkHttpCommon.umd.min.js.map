{"version":3,"sources":["../../src/utils.ts"],"names":["req","httpClient","extractFiles","multipartInfo","shouldUseBody","indexOf","method","toUpperCase","isBatching","body","length","shouldUseMultipart","options","useMultipart","Observable","observer","error","Error","files","size","bodyOrParams","clone","params","Object","keys","reduce","obj","param","value","toLowerCase","shouldStringify","JSON","stringify","form_1","FormData","append","map_1","i_1","forEach","paths","_","file","name","request","url","assign","observe","responseType","reportProgress","source","destination","headers","set","getAll","values","_i","arguments","picked","find","val"],"mappings":"8RAKqB,SACnBA,EACAC,EACAC,GAEA,IAMIC,EANEC,GAC4D,IAAhE,CAAC,OAAQ,MAAO,SAASC,QAAQL,EAAIM,OAAOC,eAGxCC,EAAcR,EAAIS,KAAgBC,OACpCC,EAAqBX,EAAIY,SAAWZ,EAAIY,QAAQC,aAMpD,GAAIF,EAAoB,CACtB,GAAIH,EACF,OAAO,IAAIM,EAAAA,YAAW,SAAAC,GACpB,OAAAA,EAASC,MACP,IAAIC,MAAM,gEAKhB,IAAKb,EACH,OAAO,IAAIU,EAAAA,YAAW,SAAAC,GACpB,OAAAA,EAASC,MACP,IAAIC,MAAM,qDAOhBN,KAFAR,EAAgBD,EAAaF,EAAIS,OAEIS,MAAMC,KAI7C,IAAIC,EAAe,GAEnB,GAAIZ,EAAY,CACd,IAAKJ,EACH,OAAO,IAAIU,EAAAA,YAAW,SAAAC,GACpB,OAAAA,EAASC,MAAM,IAAIC,MAAM,kDAI7BG,EAAe,CACbX,KAAMT,EAAIS,UAEP,CACL,IAAMA,EAAOE,EAAqBR,EAAekB,MAAQrB,EAAIS,KAE7D,GAAIL,EACFgB,EAAe,CACbX,KAAIA,QASNW,EAAe,CAACE,OANDC,OAAOC,KAAKxB,EAAIS,MAAMgB,QAAO,SAACC,EAAUC,GACrD,IAAMC,EAAS5B,EAAIS,KAAakB,GAEhC,OADAD,EAAIC,GAtDc,SAACA,GACvB,OAA8D,IAA9D,CAAC,YAAa,cAActB,QAAQsB,EAAME,eAqDzBC,CAAgBH,GAASI,KAAKC,UAAUJ,GAASA,EACvDF,IACN,KAMP,GAAIf,GAAsBP,EAAe,CACvC,IAAM6B,EAAO,IAAIC,SAEjBD,EAAKE,OAAO,aAAcJ,KAAKC,UAAWZ,EAAqBX,OAE/D,IAAM2B,EAA2B,GAC3BlB,EAAQf,EAAee,MAEzBmB,EAAI,EACRnB,EAAMoB,SAAQ,SAAAC,GACZH,IAAMC,GAAKE,KAGbN,EAAKE,OAAO,MAAOJ,KAAKC,UAAUI,IAElCC,EAAI,EACJnB,EAAMoB,SAAQ,SAACE,EAAGC,GAChBR,EAAKE,SAASE,EAAI,GAAII,EAAMA,EAAKC,SAGlCtB,EAAqBX,KAAOwB,EAI/B,OAAOhC,EAAW0C,QAAgB3C,EAAIM,OAAQN,EAAI4C,IAAGrB,OAAAsB,OAAAtB,OAAAsB,OAAA,CACnDC,QAAS,WACTC,aAAc,OACdC,gBAAgB,GACb5B,GACApB,EAAIY,0BAIiB,SAC1BqC,EACAC,GAEA,OAAID,GAAUC,EACGA,EACZ1B,OACAC,QACC,SAAC0B,EAAST,GAAS,OAAAS,EAAQC,IAAIV,EAAMQ,EAAYG,OAAOX,MACxDO,GAMCC,GAAeD,+BAGM,IAAAK,EAAA,GAAAC,EAAA,EAAAA,EAAAC,UAAA9C,OAAA6C,IAAAD,EAAAC,GAAAC,UAAAD,GAC5B,IAAME,EAASH,EAAOI,MAAK,SAAAC,GAAO,YAAe,IAARA,KAEzC,YAAsB,IAAXF,EACFH,EAAOA,EAAO5C,OAAS,GAGzB+C","sourcesContent":["import {HttpHeaders, HttpResponse, HttpClient} from '@angular/common/http';\nimport {Observable} from 'rxjs';\n\nimport {Request, Body, ExtractFiles} from './types';\n\nexport const fetch = (\n  req: Request,\n  httpClient: HttpClient,\n  extractFiles: ExtractFiles,\n): Observable<HttpResponse<Object>> => {\n  const shouldUseBody =\n    ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;\n  const shouldStringify = (param: string) =>\n    ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1;\n  const isBatching = (req.body as Body[]).length;\n  let shouldUseMultipart = req.options && req.options.useMultipart;\n  let multipartInfo: {\n    clone: Body;\n    files: Map<any, any>;\n  };\n\n  if (shouldUseMultipart) {\n    if (isBatching) {\n      return new Observable(observer =>\n        observer.error(\n          new Error('File upload is not available when combined with Batching'),\n        ),\n      );\n    }\n\n    if (!shouldUseBody) {\n      return new Observable(observer =>\n        observer.error(\n          new Error('File upload is not available when GET is used'),\n        ),\n      );\n    }\n\n    multipartInfo = extractFiles(req.body);\n\n    shouldUseMultipart = !!multipartInfo.files.size;\n  }\n\n  // `body` for some, `params` for others\n  let bodyOrParams = {};\n\n  if (isBatching) {\n    if (!shouldUseBody) {\n      return new Observable(observer =>\n        observer.error(new Error('Batching is not available for GET requests')),\n      );\n    }\n\n    bodyOrParams = {\n      body: req.body,\n    };\n  } else {\n    const body = shouldUseMultipart ? multipartInfo!.clone : req.body;\n\n    if (shouldUseBody) {\n      bodyOrParams = {\n        body,\n      };\n    } else {\n      const params = Object.keys(req.body).reduce((obj: any, param) => {\n        const value = (req.body as any)[param];\n        obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;\n        return obj;\n      }, {});\n\n      bodyOrParams = {params: params};\n    }\n  }\n\n  if (shouldUseMultipart && shouldUseBody) {\n    const form = new FormData();\n\n    form.append('operations', JSON.stringify((bodyOrParams as any).body));\n\n    const map: Record<string, any> = {};\n    const files = multipartInfo!.files;\n\n    let i = 0;\n    files.forEach(paths => {\n      map[++i] = paths;\n    });\n\n    form.append('map', JSON.stringify(map));\n\n    i = 0;\n    files.forEach((_, file) => {\n      form.append(++i + '', file, file.name);\n    });\n\n    (bodyOrParams as any).body = form;\n  }\n\n  // create a request\n  return httpClient.request<Object>(req.method, req.url, {\n    observe: 'response',\n    responseType: 'json',\n    reportProgress: false,\n    ...bodyOrParams,\n    ...req.options,\n  });\n};\n\nexport const mergeHeaders = (\n  source: HttpHeaders,\n  destination: HttpHeaders,\n): HttpHeaders => {\n  if (source && destination) {\n    const merged = destination\n      .keys()\n      .reduce(\n        (headers, name) => headers.set(name, destination.getAll(name)),\n        source,\n      );\n\n    return merged;\n  }\n\n  return destination || source;\n};\n\nexport function prioritize<T>(...values: T[]): T {\n  const picked = values.find(val => typeof val !== 'undefined');\n\n  if (typeof picked === 'undefined') {\n    return values[values.length - 1];\n  }\n\n  return picked;\n}\n"]}